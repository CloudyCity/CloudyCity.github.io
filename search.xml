<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何引用同一级查询的列别名作为新列]]></title>
    <url>%2Fp%2F1ff4.html</url>
    <content type="text"><![CDATA[火星救援，刻不容缓！示例表：12345678mysql&gt; SELECT * FROM core;+--------+--------+--------+| field1 | field2 | field3 |+--------+--------+--------+| 1 | 2 | 3 || 4 | 5 | 6 |+--------+--------+--------+2 rows in set (0.00 sec) MySQL中无法直接执行以下查询：123456mysql&gt; SELECT -&gt; field1 + field2 AS col1, -&gt; col1 + field3 AS col2 -&gt; FROM -&gt; core;ERROR 1054 (42S22): Unknown column 'col1' in 'field list' 但有三种方案实现这个效果。 子查询123456789101112mysql&gt; SELECT -&gt; col1, -&gt; col1 + field3 AS col2 -&gt; FROM -&gt; ( SELECT field1 + field2 AS col1, field3 FROM core ) AS subQuery;+------+------+| col1 | col2 |+------+------+| 3 | 6 || 9 | 15 |+------+------+2 rows in set (0.00 sec) 用户变量123456789101112mysql&gt; SELECT -&gt; @col1 := ( field1 + field2 ) AS col1, -&gt; @col1 + field3 AS col2 -&gt; FROM -&gt; core;+------+------+| col1 | col2 |+------+------+| 3 | 6 || 9 | 15 |+------+------+2 rows in set, 1 warning (0.00 sec) 这里结果显示了一个warning: SELECT里的表达式在被发送到mysql客户端时才会被执行，所以用户变量在HAVING、GROUP BY、ORDER BY中无法使用。 引用别名123456789101112mysql&gt; SELECT -&gt; field1 + field2 AS col1, -&gt; ( SELECT col1 ) + field3 AS col2 -&gt; FROM -&gt; core;+------+------+| col1 | col2 |+------+------+| 3 | 6 || 9 | 15 |+------+------+2 rows in set (0.00 sec) 与用户变量类似，在GROUP BY中无法使用。 在GROUP BY里中使用引用:12345678mysql&gt; SELECT -&gt; MAX( field1 ) AS col1, -&gt; ( SELECT col1 ) AS col2 -&gt; FROM -&gt; core -&gt; GROUP BY -&gt; field1;ERROR 1247 (42S22): Reference 'col1' not supported (reference to group function) Referenceshttps://stackoverflow.com/questions/6081436/how-to-alias-a-field-or-column-in-mysql#]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Docker搭建LNMP环境]]></title>
    <url>%2Fp%2Fb254.html</url>
    <content type="text"><![CDATA[人类的本质是复读机。 安装docker查看内核版本12$ uname -r3.10.0-957.el7.x86_64 更新yum包1$ yum update 添加包源12345$ yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoLoaded plugins: fastestmirror, langpacksadding repo from: https://download.docker.com/linux/centos/docker-ce.repograbbing file https://download.docker.com/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.reporepo saved to /etc/yum.repos.d/docker-ce.repo 查看版本123456789101112131415161718192021222324252627282930$ yum list docker-ce --showduplicates | sort -rLoading mirror speeds from cached hostfileLoaded plugins: fastestmirror, langpacksdocker-ce.x86_64 3:18.09.8-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.7-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.6-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.5-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.4-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.3-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.2-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.3.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.2.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.03.1.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 18.03.0.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 17.12.1.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 17.12.0.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 17.09.1.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 17.09.0.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 17.06.2.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 17.06.1.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 17.06.0.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 17.03.3.ce-1.el7 docker-ce-stabledocker-ce.x86_64 17.03.2.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 17.03.1.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 17.03.0.ce-1.el7.centos docker-ce-stableAvailable Packages 安装1$ yum install docker-ce-18.03.1.ce 启动1$ systemctl start docker 设置开机启动 (可选)12$ systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 查看1234567891011121314151617181920$ docker versionClient: Version: 18.03.1-ce API version: 1.37 Go version: go1.9.5 Git commit: 9ee9f40 Built: Thu Apr 26 07:20:16 2018 OS/Arch: linux/amd64 Experimental: false Orchestrator: swarmServer: Engine: Version: 18.03.1-ce API version: 1.37 (minimum version 1.12) Go version: go1.9.5 Git commit: 9ee9f40 Built: Thu Apr 26 07:23:58 2018 OS/Arch: linux/amd64 Experimental: false 安装docker-compose从github安装1$ curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose 给予执行权限1$ chmod +x /usr/local/bin/docker-compose 查看12$ docker-compose --versiondocker-compose version 1.24.1, build 4667896b 搭建LNMP这里直接用yeszao/dnmp的配置。 选取目录选择一个存放容器配置的目录(只是配置文件位置，镜像与容器在/var/lib/docker目录中)1$ cd ~ &amp;&amp; mkdir dnmp &amp;&amp; cd dnmp 拉取配置12$ git clone git@github.com:yeszao/dnmp.git # 这里用的是v2.0.4的tag$ cp env.sample .env &amp;&amp; cp docker-compose.sample.yml docker-compose.yml 修改配置这里docker-compose.yml 只开启了nginx、php、mysql8和redis，.env 给php加了一些扩展。123456# .envPHP_VERSION=7.2.19PHP_PHP_CONF_FILE=./conf/php.iniPHP_FPM_CONF_FILE=./conf/php-fpm.confPHP_LOG_DIR=./log/phpPHP_EXTENSIONS=pdo_mysql,mysqli,mbstring,gd,curl,opcache,redis,imap,swoole,xhprof,acpu 所有配置文件都在~/dnmp/services/目录中，所有日志都在~/dnmp/log中，具体见yeszao/dnmp。 执行构建在配置文件处执行123456$ docker-compose up -dCreating network "dnmp_default" with the default driverCreating redis ... doneCreating mysql ... doneCreating php ... doneCreating nginx ... done 初始构建需要一定时间，如果构建时无法下载组件，需要给容器指定dns服务器。 查看宿主机nameserver 12345678$ cat /etc/resolv.conf# Your system has been configured with &apos;manage-resolv-conf&apos; set to true.# As a result, cloud-init has written this file with configuration data# that it has been provided. Cloud-init, by default, will write this file# a single time (PER_ONCE).#nameserver 183.60.83.19nameserver 183.60.82.98 新建或修改/etc/default/docker 1DOCKER_OPTS=&quot;--dns 183.60.83.19&quot; 重启docker 1systemctl restart docker 查看容器1234567$ docker-compose psName Command State Ports----------------------------------------------------------------------------------------mysql docker-entrypoint.sh mysqld Up 0.0.0.0:3306-&gt;3306/tcp, 33060/tcpnginx nginx -g daemon off; Up 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:80-&gt;80/tcpphp docker-php-entrypoint php-fpm Up 9000/tcp, 9501/tcpredis redis-server /etc/redis.conf Up 0.0.0.0:6379-&gt;6379/tcp 配置命令别名从bash.alias.sample提取需要的别名到~/.bashrc或~/.zshrc中，然后重新source生效123456789101112131415161718192021222324252627282930alias dnginx='docker exec -it nginx /bin/sh'alias dphp='docker exec -it php /bin/sh'alias dmysql='docker exec -it mysql /bin/bash'alias dredis='docker exec -it redis /bin/sh'php () &#123; tty= tty -s &amp;&amp; tty=--tty docker run \ $tty \ --interactive \ --rm \ --volume $PWD:/www:rw \ --workdir /www \ dnmp_php php "$@"&#125;composer() &#123; tty= tty -s &amp;&amp; tty=--tty docker run \ $tty \ --interactive \ --rm \ --user www-data:www-data \ --volume ~/dnmp/data/composer:/tmp/composer \ --volume $(pwd):/app \ --workdir /app \ dnmp_php composer "$@"&#125; ReferencesGet Docker CE for CentOSInstall Docker Composeyeszao/dnmp]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Webpack开发JS Sdk]]></title>
    <url>%2Fp%2Fb8f0.html</url>
    <content type="text"><![CDATA[最近项目需要开发一个JS Sdk，为了保证可读性与可维护性，决定按模块开发，最后使用webpack打包。 文件结构123456789101112131415161718|-- config| |-- webpack.base.js| |-- webpack.development.js| `-- webpack.production.js|-- dist| |-- mars_minigame_sdk.js| `-- mars_minigame_sdk.min.js|-- node_modules|-- package-lock.json|-- package.json|-- src| |-- index.js # SDK入口| |-- lib| | `-- util.js # 工具函数| `-- sdk # 各渠道SDK| |-- qq.js | `-- wechat.js`-- webpack.config.js 安装依赖12npm install -g webpack webpack-clinpm install --save-dev webpack webpack-cli webpack-merge uglifyjs-webpack-plugin babel-loader 配置webpackconfig\webpack.base.js1234567891011121314151617181920212223242526272829const path = require('path')module.exports = &#123; entry: &#123; 'mars_minigame_sdk': '@/index.js' &#125;, output: &#123; path: path.resolve(__dirname, '../dist'), filename: '[name].min.js', library: 'mars_mg_sdk', libraryTarget: "umd" &#125;, module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, use: &#123; loader: "babel-loader" &#125; &#125; ] &#125;, resolve: &#123; alias: &#123; '@': path.resolve('src') &#125; &#125;&#125; config\webpack.development.js1234567const merge = require("webpack-merge");module.exports = &#123; devtool: 'source-map', output: &#123; filename: '[name].js', &#125;&#125; config\webpack.production.js123456const merge = require("webpack-merge");module.exports = &#123; output: &#123; filename: '[name].min.js', &#125;&#125; webpack.config.js1234567891011const merge = require('webpack-merge');const baseConfig = require('./config/webpack.base');const developmentConfig = require('./config/webpack.development');const productionConfig = require('./config/webpack.production');module.exports = mode =&gt; &#123; if (mode === "production") &#123; return merge(baseConfig, productionConfig, &#123; mode &#125;); &#125; return merge(baseConfig, developmentConfig, &#123; mode &#125;);&#125; package.json12345678910111213141516171819202122232425262728293031323334&#123; "name": "mars_mg_sdk", "version": "1.0.0", "description": "火星救援小游戏SDK", "private": true, "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "npm run dev", "dev": "webpack --watch --env development", "build": "webpack --env production", "server": "webpack-dev-server --open --env development" &#125;, "repository": &#123; "type": "git", "url": "ssh://git@gitlab.mars.com/lcpd/mars_mg_sdk.git" &#125;, "keywords": [ "火星救援", "小游戏", "SDK" ], "author": "Mars Developer", "license": "MIT", "dependencies": &#123;&#125;, "devDependencies": &#123; "@babel/core": "^7.5.4", "babel-loader": "^8.0.6", "uglifyjs-webpack-plugin": "^2.1.3", "webpack": "^4.35.3", "webpack-cli": "^3.3.5", "webpack-dev-server": "^3.7.2", "webpack-merge": "^4.2.1" &#125;&#125; 业务代码index.js1234567891011const qqSdk = require('./sdk/qq');const wechatSdk = require('./sdk/wechat');const util = require('./lib/util');window.apiHost = 'https://api.mp.mars.com/';module.exports = &#123; init: function (e) &#123;&#125;, login: function (e) &#123;&#125;, pay: function (e) &#123;&#125;&#125; sdk\wechat.js1234567const util = require('../lib/util');module.exports = &#123; init: function (e) &#123;&#125;, login: function (e) &#123;&#125;, pay: function (e) &#123;&#125;&#125; 打包打包开发环境文件，即打包成mars_minigame_sdk.js。启动命令参数加了--watch，文件改动时会自动打包。1npm run dev 打包生产环境文件，即mars_minigame_sdk.min.js1npm run build 使用SDK以微信开发工具为例 References用 webpack 写一个简单的 JS SDK]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel5.8+Dingo+JWT+Swagger 开发API]]></title>
    <url>%2Fp%2F9f9d.html</url>
    <content type="text"><![CDATA[在Laravel5.8中使用“Laravel必知必会”的两个轮子dingo/api和tymon/jwt-auth以及文档系统swagger-api/swagger-ui开发一个规范优雅的API。 Dingo安装1composer require dingo/api 组件包含自动包发现配置，无需手动注册Provider 配置1php artisan vendor:publish --provider="Dingo\Api\Provider\LaravelServiceProvider" 无特殊需求直接通过.env文件配置12345678910# Dingo Api API_STANDARDS_TREE=xAPI_SUBTYPE=mp_adminAPI_PREFIX=api # 前缀API_VERSION=v1 # 默认版本API_NAME="Mp Admin API" # 名称API_CONDITIONAL_REQUEST=false # 条件请求API_STRICT=false # 严格模式，开启时请求头必要带标准的Accept信息API_DEFAULT_FORMAT=jsonAPI_DEBUG=true # 调试 由于子域已被占用，这里采用前缀的格式。接口地址格式为：https://admin.mp.example.com/api 路由12345678910111213141516171819202122232425262728293031/* @var \Dingo\Api\Routing\Router $api */$api = app('Dingo\Api\Routing\Router');$api-&gt;version('v1', function () use ($api) &#123; $api-&gt;group(['middleware' =&gt; ['api', 'bindings']], function () use ($api) &#123; // 系统调试日志 $api-&gt;get('dev-logs', ['as' =&gt; 'dev-logs', 'uses' =&gt; '\Rap2hpoutre\LaravelLogViewer\LogViewerController@index', 'middleware' =&gt; ['auth']]); // 验证 $api-&gt;group(['prefix' =&gt; 'auth'], function () use ($api) &#123; $api-&gt;post('login', ['as' =&gt; 'auth.login', 'uses' =&gt; 'App\Http\Controllers\AuthController@login']); $api-&gt;get('me', ['as' =&gt; 'auth.me', 'uses' =&gt; 'App\Http\Controllers\AuthController@me']); $api-&gt;post('refresh', ['as' =&gt; 'auth.refresh', 'uses' =&gt; 'App\Http\Controllers\AuthController@refresh']); $api-&gt;post('logout', ['as' =&gt; 'auth.logout', 'uses' =&gt; 'App\Http\Controllers\AuthController@logout']); $api-&gt;put('reset-pwd', ['as' =&gt; 'auth.reset-pwd', 'uses' =&gt; 'App\Http\Controllers\AuthController@resetPwd']); &#125;); // 系统 $api-&gt;group(['prefix' =&gt; 'sys'], function () use ($api) &#123; // 当前用户能看到的菜单与拥有的权限(别名) $api-&gt;get('menu', ['as' =&gt; 'sys.menu', 'uses' =&gt; 'App\Http\Controllers\System\AdminController@menu']); // 系统资源 $api-&gt;resource('permissions', 'App\Http\Controllers\System\PermissionController', ['names' =&gt; 'sys.permissions']); $api-&gt;resource('roles', 'App\Http\Controllers\System\RoleController', ['names' =&gt; 'sys.roles']); $api-&gt;resource('admins', 'App\Http\Controllers\System\AdminController', ['names' =&gt; 'sys.admins']); &#125;); ... &#125;);&#125;); 所有控制器都需要完整的命名空间，不支持为群组配置命名空间 异常定义异常Dingo已经定义了接口场景下常用的异常，所以相关异常可以继承\Dingo\Api\Exception\下的异常。例如：123456789class UpdateResourceFailedException extends \Dingo\Api\Exception\UpdateResourceFailedException&#123; protected $message = '更新失败'; public function __construct($message = null, $errors = null, \Exception $previous = null, $headers = [], $code = 0) &#123; $message = $message ?? $this-&gt;getMessage(); parent::__construct($message, $errors, $previous, $headers, $code); &#125;&#125; 自定义异常响应Dingo会先于Laravel自带的Handle获取Symfony\Component\HttpKernel\Exception，所以在系统Handle::render()中处理不了这些异常。需要这样：1234567891011121314151617class AppServiceProvider extends ServiceProvider&#123; /** * Register any application services. * * @return void */ public function register() &#123; // 优化显示验证异常 app('Dingo\Api\Exception\Handler')-&gt;register(function (ValidationException $exception) &#123; $error = $exception-&gt;validator-&gt;errors()-&gt;first(); throw new ValidationHttpException($error); &#125;); &#125; ... Transformers目前通过Eloquent ORM的$casts属性来自动转化字段类型，还没复杂的需求需要用到Transformers。 JWT安装Laravel 5.5以上需要使用1.0.0版本1composer require "tymon/jwt-auth:1.0.0-rc.4.1" 在config/app.php中手动注册Provider123456'providers' =&gt; [ ... Tymon\JWTAuth\Providers\LaravelServiceProvider::class,] 配置发布配置1php artisan vendor:publish --provider="Tymon\JWTAuth\Providers\LaravelServiceProvider" 生成密钥(可选)1php artisan jwt:secret 配置ENV123# JWT OauthJWT_SECRET=F5C5Qodnaa78PGFTFGhWgt7cNaHCOcXTI6SdtfuCfjHpotu7uwmlTy8HlbvsXeNt #64位密钥JWT_TTL=1440 #Token过期时间 使用验证定义一个控制器基类，在构造函数中指定验证中间件即可。12345678910111213141516class Controller extends BaseController&#123; use AuthorizesRequests, DispatchesJobs, ValidatesRequests, Helpers; /** * Create a new AuthController instance. * * @return void */ public function __construct() &#123; if (needAuth()) &#123; // 助手函数，开发环境不验证Token $this-&gt;middleware('auth:api', ['except' =&gt; ['login']]); &#125; &#125;&#125; 之后所有路由到此控制器子类的请求必须带有Authorization头，值为Bearer $token才能通过检验。 只有继承这个基类的控制器才会进行检验，如果不是其子类需要在路由中指定中间件，例如上面路由中dev-logs的例子。 验证控制器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class AuthController extends Controller&#123; public function login(LoginRequest $request) &#123; $credentials = $request-&gt;only(['email', 'password']); $auth = auth(); if (!$token = $auth-&gt;attempt($credentials)) &#123; return response()-&gt;json(['error' =&gt; 'Unauthorized', 'status_code' =&gt; 401], 401); &#125; return $this-&gt;respondWithToken($token); &#125; public function me() &#123; return response()-&gt;json(auth()-&gt;user()); &#125; public function logout() &#123; auth()-&gt;logout(); return response()-&gt;json(['message' =&gt; 'Successfully logged out']); &#125; public function refresh() &#123; /** @noinspection PhpUndefinedMethodInspection */ return $this-&gt;respondWithToken(auth()-&gt;refresh()); &#125; public function resetPwd(ResetPwdRequest $request) &#123; $oldPassword = $request-&gt;get('old_password'); $newPassword = $request-&gt;get('new_password'); // 检查旧密码 $admin = auth()-&gt;user(); if (!password_verify($oldPassword, $admin-&gt;password)) &#123; throw new AuthenticationException('密码错误'); &#125; // 更新密码 $admin-&gt;update([ 'password' =&gt; password_hash($newPassword, PASSWORD_DEFAULT) ]); return success(); &#125; protected function respondWithToken($token) &#123; /** @noinspection PhpUndefinedMethodInspection */ return $this-&gt;response-&gt;array([ 'access_token' =&gt; $token, 'token_type' =&gt; 'bearer', 'expires_in' =&gt; auth()-&gt;factory()-&gt;getTTL() * 60 ])-&gt;withHeader('Authorization', $token); &#125;&#125; Swagger这里采用l5-swagger扩展，集成了swagger-ui（使用json配置的文档系统）和php-swagger(使用代码注释生成json配置)。 安装1composer require "darkaonline/l5-swagger:5.8.*" 在config/app.php中手动注册Provider123456'providers' =&gt; [ ... L5Swagger\L5SwaggerServiceProvider::class,] 配置发布配置与视图模板1php artisan vendor:publish --provider "L5Swagger\L5SwaggerServiceProvider" 修改配置config/l5-swagger.php1234567891011121314151617181920212223242526272829return [ 'api' =&gt; [ /* |-------------------------------------------------------------------------- | Edit to set the api's title |-------------------------------------------------------------------------- */ 'title' =&gt; '后台Api文档', # 文档页面的标题 ], 'routes' =&gt; [ /* |-------------------------------------------------------------------------- | Route for accessing api documentation interface |-------------------------------------------------------------------------- */ 'api' =&gt; 'api/docs', # 文档页面的路由 /* |-------------------------------------------------------------------------- | Route for accessing parsed swagger annotations. |-------------------------------------------------------------------------- */ 'docs' =&gt; 'docs', # 路由别名 ... 在.env中添加123# SwaggerSWAGGER_VERSION=3.0 # php-swagger的版本，不同版本注释写法不同！L5_SWAGGER_GENERATE_ALWAYS=true # 自动生成文档json，不要在生产环境打开此项 最后记得将文档的json配置加入.gitignore12.../storage/api-docs/api-docs.json 编写Swagger注释这里不详细介绍php-swagger的注释语法，只放出几个例子： swagger.php 1234567891011121314151617181920212223242526272829303132&lt;?php/** * * @OA\OpenApi( * security=&#123; * &#123; * "Bearer":&#123;&#125; * &#125; * &#125;, * @OA\Server( * url=L5_SWAGGER_CONST_HOST * ) * ) * * @OA\Info( * version="1.0", * title="小程序后台Api文档", * @OA\Contact( * name="火星救援网络科技有限公司", * url="http://www.example.com/" * ) * ) * * @OA\SecurityScheme( * securityScheme="Bearer", * type="apiKey", * name="Authorization", * in="header", * ) * */ swagger-tags.php 123456789101112131415161718192021/** * @OA\Tag( * name="Auth", * description="验证模块" * ) * * @OA\Tag( * name="System.Permission", * description="系统模块中的权限管理" * ) * * @OA\Tag( * name="System.Role", * description="系统模块中的角色管理" * ) * * @OA\Tag( * name="System.Admin", * description="系统模块中的用户管理" * ) */ AuthController.php 12345678910111213141516171819202122232425262728293031323334353637383940414243class AuthController extends Controller&#123; /** * @OA\Post( * path="/auth/login", * summary="获取凭证", * tags=&#123;"Auth"&#125;, * description="通过账号密码获取Access Token", * @OA\Parameter( * name="email", * in="query", * required=true, * @OA\Schema( * type="string" * ), * example="test@example.com", * description="邮箱" * ), * @OA\Parameter( * name="password", * in="query", * required=true, * @OA\Schema( * type="string" * ), * description="密码" * ), * @OA\Response( * response=200, * description="返回凭证", * ref="#/components/schemas/Token" * ), * @OA\Response( * response=401, * description="账号不存在或密码错误" * ) * ) * * @param LoginRequest $request * @return \Illuminate\Http\JsonResponse */ public function login(LoginRequest $request) &#123; ... 注释可以写在项目任意php文件中，建议是有归属语义的注释写在归属代码上（例如接口注释写在控制器中，模型注释写在模型中），公共语义的注释一样单独写在一个php文件中。 生成文档json1php artisan l5-swagger:generate 最终效果访问上面配置的路由地址 点击Authorize按钮，value填入Authorization头的值即可在生产环境的文档页面请求接口。 注释可以写在项目任意php文件中，建议是有归属语义的注释写在归属代码上（例如接口注释写在控制器中，模型注释写在模型中），公共语义的注释一样单独写在一个php文件中。 结语至此，三个轮子在入门应用就介绍完了，这些轮子可以让你更快速的搭建API，专注于业务逻辑。 References[0] dingo/api[1] tymon/jwt-auth[2] swagger-api/swagger-ui]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo提高加载速度]]></title>
    <url>%2Fp%2F6cf2.html</url>
    <content type="text"><![CDATA[Hexo作为纯静态博客最大的优点就是快，但要真正的快起来你可能需要做这些事情。 托管平台（可选）直接在Coding等国内平台托管Page项目，修改国内线路解析。(可参照Github Hexo的百度收录问题)Coding绑定了域名需定期申请SSL证书，所以本博放弃此项。 CDN加速这里只是针对第三方静态文件的加速，修改Next主题配置文件_config.yml如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js # https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js fancybox_css: https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: https://cdn.bootcss.com/velocity/1.2.1/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: https://cdn.bootcss.com/pace/1.0.2/pace.min.js pace_css: https://cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css 针对自定义的静态文件(main.min.js和main.min.css)需要自行使用融合CDN，国内都需要备案域名，本博的.me域名没有备案资质，但我不太想将静态文件放到其他域名，所以放弃加速这类文件。 压缩文件hexo-neat安装1npm install hexo-neat --save 配置修改项目_config.yml。123456789101112131415neat_enable: trueneat_html: enable: true exclude:neat_css: enable: false exclude: - &apos;**/*.min.css&apos;neat_js: enable: false mangle: true output: compress: exclude: - &apos;**/*.min.js&apos; 后面会使用gulp合并与压缩js与css，所以此处只用neat压缩了html。如果你不想使用合并js与css，此处可以打开neat_js、neat_css。 gulpgulp是自动化构建工具，这里主要是用来合并、压缩js与css。 构建配置Next主题目录自带了gulpfile.coffee，这里直接修改：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485fs = require(&apos;fs&apos;)path = require(&apos;path&apos;)gulp = require(&apos;gulp&apos;)jshint = require(&apos;gulp-jshint&apos;) # js语法检查jslish = require(&apos;jshint-stylish&apos;) # js语法检查输出美化stylint = require(&apos;gulp-stylint&apos;) # stylus语法检查stylish = require(&apos;stylint-stylish&apos;) # stylus语法检查输出美化yaml = require(&apos;js-yaml&apos;)concat = require(&apos;gulp-concat&apos;) # js合并uglify = require(&quot;gulp-uglify&quot;) # js压缩concatCss = require(&apos;gulp-concat-css&apos;) # css合并cleanCss = require(&apos;gulp-clean-css&apos;) # css压缩# js语法检查 https://jshint.com/docs/options/gulp.task &apos;lint:js&apos;, -&gt; return gulp.src path.join(__dirname, &apos;./source/js/**/*.js&apos;) .pipe jshint() .pipe jshint.reporter()# stylus语法检查 https://github.com/SimenB/stylintgulp.task &apos;lint:stylus&apos;, -&gt; return gulp.src path.join(__dirname, &apos;/source/css/**/*.styl&apos;) .pipe stylint(&#123;config: path.join(__dirname, &apos;.stylintrc&apos;)&#125;) .pipe stylint.reporter(stylish)# 配置文件检验gulp.task &apos;validate:config&apos;, (cb) -&gt; themeConfig = fs.readFileSync path.join(__dirname, &apos;_config.yml&apos;) try yaml.safeLoad(themeConfig) cb() catch error cb new Error(error)# 语言文件检验gulp.task &apos;validate:languages&apos;, (cb) -&gt; languagesPath = path.join __dirname, &apos;languages&apos; languages = fs.readdirSync languagesPath errors = [] for lang in languages languagePath = path.join languagesPath, lang try yaml.safeLoad fs.readFileSync(languagePath), &#123; filename: path.relative(__dirname, languagePath) &#125; catch error errors.push error if errors.length == 0 cb() else cb(errors)# 合并压缩js# gulp.task &apos;minify:js&apos;, [&apos;lint:js&apos;], (cb) -&gt;gulp.task &apos;minify:js&apos;, (cb) -&gt; return gulp.src([ path.join(__dirname, &apos;source/js/src/utils.js&apos;), path.join(__dirname, &apos;source/js/src/motion.js&apos;), path.join(__dirname, &apos;source/js/src/gitment.browser.js&apos;), path.join(__dirname, &apos;source/js/src/bootstrap.js&apos;), path.join(__dirname, &apos;source/js/src/scrollspy.js&apos;), path.join(__dirname, &apos;source/js/src/post-details.js&apos;), ]).pipe concat(&apos;main.min.js&apos;) .pipe uglify() .pipe gulp.dest path.join __dirname, &apos;../../public/js&apos;# 合并压缩js# gulp.task &apos;minify:css&apos;, [&apos;lint:stylus&apos;], (cb) -&gt;gulp.task &apos;minify:css&apos;, (cb) -&gt; return gulp.src([ path.join(__dirname, &apos;../../public/css/main.css&apos;), path.join(__dirname, &apos;source/css/src/gitment.css&apos;), ]).pipe concat(&apos;main.min.css&apos;) .pipe cleanCss() .pipe gulp.dest path.join __dirname, &apos;../../public/css&apos;# 执行gulp.task &apos;default&apos;, [ &apos;validate:config&apos;, &apos;validate:languages&apos; &apos;minify:js&apos;, &apos;minify:css&apos;,] Next主题默认的gulpfile.coffee只是进行规范检查，不过此处修改后默认关闭，按需开启。合并js时尽量保持模板中引入的顺序，避免不必要错误。在项目根目录下新建gulpfile.js：12require(&apos;coffeescript/register&apos;)require(&apos;./themes/next/gulpfile.coffee&apos;)#### 安装相关依赖安装构建任务用到的依赖。1234567891011npm install gulp -gnpm install coffeescript --save-dev # 用于在gulpfile.js中引入gulpfile.coffeenpm install gulp-clean-css --save-dev # css压缩npm install gulp-concat --save-dev # js合并npm install gulp-concat-css --save-dev # css合并npm install gulp-jshint --save-dev # js语法检查npm install gulp-stylint --save-dev # css语法检查npm install gulp-uglify --save-dev # js压缩npm install jshint --save-dev # js压缩核心npm install jshint-stylish --save-dev # js语法检查输出美化npm install stylint-stylish --save-dev # css语法检查输出美化#### 执行构建项目根目录执行gulp：构建输出合并与压缩后的文件：#### 更新模板修改themes/next/layout/_partials/head.swig:1234567&lt;link href=&quot;&#123;&#123; font_awesome_uri &#125;&#125;&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;link href=&quot;&#123;&#123; url_for(theme.css) &#125;&#125;/main.css?v=&#123;&#123; theme.version &#125;&#125;&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;link href=&quot;&#123;&#123; url_for(theme.css) &#125;&#125;/main.min.css?v=&#123;&#123; theme.version &#125;&#125;&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &#123;% if theme.favicon.apple_touch_icon %&#125; &#123;% if theme.favicon.apple_touch_icon %&#125;修改themes/next/layout/_layout.swig:123&#123;% include &apos;_scripts/vendors.swig&apos; %&#125; &lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; url_for(theme.js) &#125;&#125;/main.min.js?v=&#123;&#123; theme.version &#125;&#125;&quot;&gt;&lt;/script&gt; &#123;% include &apos;_scripts/commons.swig&apos; %&#125; &#123;% include &apos;_scripts/commons.swig&apos; %&#125;然后在各模板中将引入合并前静态文件的部分注释掉，这里不详细列出，只放出一个例子：完成后重新部署：1hexo g &amp;&amp; gulp &amp;&amp; hexo d引用效果：## 图片懒加载可以显著加速文章页。安装插件:1npm install hexo-lazyload-image --save修改项目配置文件_config.yml:12345# 图片懒加载lazyload: enable: true onlypost: false loadingImg: /images/loading/loading.gif #如果不填写图片则使用默认的图片## 精简功能功能涉及多个请求时会比较明显得拖慢加载速度，例如不蒜子、DaoVice，要考量这些功能是否真(hua)的(er)需(bu)要(shi)。（像我已经关掉了DaoVice，只留着不蒜子计算站点UV）## 最终效果首页文章页剩下的瓶颈主要是Gitment、不蒜子。不同网络环境下的加速效果也会不同，以上效果是我在家中的加速效果。在公司的加速效果就差了很多。]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Hexo的百度收录问题]]></title>
    <url>%2Fp%2Fc283.html</url>
    <content type="text"><![CDATA[Github屏蔽了百度的爬虫，所以部署在Github Page的Hexo无法被百度收录，如果你绑定了自定义域名的话，这里有几个曲线救国方案。 私有主机将博客部署到自己的机器上。 对象存储将博客上传到对象存储。 国内托管在国内的代码托管平台部署Hexo，这里推荐Coding，流程与部署到Github基本一致。 分线路解析以Github Page + Coding Page 为例。 部署多项目Coding的项目只需要master分支，Hexo的_config.yml增加仓库地址，然后执行hexo d便可以同时部署到两个项目。 DNS解析注意：如果要开启HTTPS，解析之前要先确保Coding Page的SSL证书已经申请通过，后面会说明原因。 默认解析到coding.me，境外解析到github.io。 然后百度的爬虫在大陆就会访问到Coding Page，就能正常收录了。 Coding Page的一大缺点是SSL证书每三个月需要手动申请一次，并且每次申请时需要先将境外指向Github Page的规则先暂停（因为Coding的认证服务器在境外）。 总结多线路解析看上去是比较优雅的解决方案。但是如果要开启HTTPS的话，相对于GitHub Page的自动延期SSL证书，Coding Page需要定期手动申请确实比较麻烦。至于其他国内的托管平台，Gitcafe目前无法访问，Gitee Page没有开启HTTPS的选项。]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Hexo绑定域名]]></title>
    <url>%2Fp%2F58f7.html</url>
    <content type="text"><![CDATA[火星救援，刻不容缓！ 域名比较流行的是.me顶级域名，简洁直观，不过没有备案资质。这里我用的就是cloudycity.me。 购买关于购买，这里有个非常赞的域名注册商比价网站哪煮迷。我是在西部数码注册的，首年20续费98。 解析添加两条CNAME规则将@与www都指向Github page地址： Github添加CNAME文件在source分支中的source目录下新建一个CNAME文件，内容为绑定的域名： 然后重新部署博客。 申请HTTPS到仓库设置中的Github Page子项中勾选Enforce HTTPS 添加CNAME文件之后，项目设置中会自动识别域名。刚识别完域名的1分钟内还无法勾选Enforce HTTPS，勾选之后要等几个小时才能生效。 后续更新相关配置如果你的博客有插件涉及域名要记得修改，例如： gitment插件用到的授权应用需要重新创建，详见hexo使用github issue存放文章与评论 Next主题的文章访问计数需要去leancloud的项目添加安全域名]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用satis搭建私有Composer库]]></title>
    <url>%2Fp%2Feee3.html</url>
    <content type="text"><![CDATA[人类的本质是复读机。最近整理项目，将一些复用的轮子封装成Composer组件，但不便于放在packgist.org，所以需要搭建私有的Composer库。 开发composer组件以之前的一遍文章 Laravel/Lumen 扩展DB Builder语法 的功能为例。 在组件项目（这里称为A项目）根目录创建composer.json。 1234567891011121314151617181920212223242526272829&#123; "name": "xuyang/laravel-builder-ext", "type": "library", "description": "扩展Laravel DB Builder的查询语法", "keywords": ["laravel", "db", "builder", "extend"], "license": "MIT", "authors": [ &#123; "name": "cloudycity", "email": "cloudycity@foxmail.com" &#125; ], "minimum-stability": "dev", "require": &#123; "php": "&gt;=5.4.0", "laravel/framework" : "^5.2" &#125;, "require-dev": &#123; "phpunit/phpunit": "4.*" &#125;, "autoload": &#123; "psr-4": &#123; "Xuyang\\LaravelBuilderExt\\": "src/" &#125; &#125;, "extra": &#123; "branch-alias": &#123; "dev-master": "1.0.0-dev" &#125; &#125;&#125; 最后传上gitlab。 搭建satis并索引组件安装satis使用composer (方法一)12$ cd /data/www/$ composer create-project composer/satis --keep-vcs 使用docker (方法二)1$ docker pull composer/satis 配置satis进入到satis项目根目录下创建satis.json。12345678910&#123; "name": "私有Composer库", "homepage": "http://satis.example.com", "repositories": [ &#123; "type": "git", "url": "ssh://git@gitlab.example.com/sub/laravel-builder-ext.git" &#125; ], "require": &#123; "company/package": "dev-master" &#125;&#125; 创建索引使用composer (方法一)1$ php bin/satis build satis.json ./web-v 这里的web就是索引输出目录。 使用docker (方法二)1$ docker run --rm -it -v /build:/build composer/satis 自动索引最简单粗暴的方法是用crontab，但这里推荐使用GitLab Web Hook: 在satis项目创建一个接口执行创建索引的操作。 1234567891011121314&lt;?php$valid_token = '3.1415926535857'; // GitLab web hook的token$valid_ip = ['127.0.0.1']; // GitLab服务器IP$client_token = $_SERVER['HTTP_X_GITLAB_TOKEN'];$client_ip = $_SERVER['REMOTE_ADDR'];if ($client_token !== $valid_token) die('Token mismatch!');if (!in_array($client_ip, $valid_ip)) die('Ip mismatch!');$ouptut = [];exec("cd /data/www/satis/; php bin/satis build satis.json ./web -v 2&gt;&amp;1", $output); // 创建索引的命令var_dump($output); 在组件的GitLab仓库中增加Web Hook 每次组件推送新提交之后都会触发钩子请求satis创建索引。 配置Nginx (可选)将satis.json中的homepage指向索引输出目录，然后就可以访问satis的界面。 添加部署密钥 (可选)如果satis所在机器没有权限拉取gitlab仓库，需要生成key并加入到gitlab的Deploy Keys(只读)中。 从satis引入composer组件修改使用A项目组件的项目（这里称B项目）的composer.json，加上私有库源：12345678910 ... "config": &#123; "preferred-install": "dist", "secure-http": false &#125;, "repositories": [&#123; "type": "composer", "url": "http://satis.example.com" &#125;]&#125; &quot;secure-http&quot;: false是可选项，当你的私有库地址不支持https时才需要加上。 然后正常引入即可： References使用satis自建私有镜像]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何更好的通过IDE代码检查]]></title>
    <url>%2Fp%2F71f5.html</url>
    <content type="text"><![CDATA[我身边有很多同事都没有重视代码检查，每次看他们IDE右侧都是一边红黄棕交错的“线谱”，特别难受。让自己的代码通过IDE的检查，可以避免很多低级的错误。下面分享下如何更好地通过Intellij系列IDE的代码检查。 目标是什么目标是无任何notice，包括英文的拼写检查。 为什么要达成目标通过代码检查可以： 一定程度上规范开发 更容易发现bug，避免低级错误 如何达成目标遵守必要规则至于判断【规则是否必要】的标准因人而异，但确定是【必要规则】就必须遵守，这是代码检查的意义。 关闭不必要规则全局关闭不必要的检查规则，例如No data sources configured、SQL dialect detection等等，可以将其关闭。 在Inspection Notice处按Alt+Enter打开Inspection setting： 去掉勾： 效果： 单次忽略有些规则是必要的，但因为某些原因我们无法遵守。可以选择Suppress for statement，将会自动在Notice前加入一行注释告诉IDE忽略掉此处的检查。 引导IDE某些场景规则是必要的，我们也遵守了，只是IDE没有get到仍标出Notice，这时候就需要想办法引导IDE去get到。 添加注释以常见的闭包Notice为例，内部都会报warning： 使用/** @var 变量类型 $var */声明 添加助手文件IDE无法识别Laravel的Facade的静态调用方式 这时候需要创建额外的助手文件ide-helper.php，里面存放类声明： IDE识别后： P.S. 助手文件本身是可以忽略检查，即选择suppress all for file项。 拼写检查英文拼写检查的优先级比较低，但能遵守的话可以避免一些奇怪的命名 使用下划线或驼峰通过检查 将专有名词加入字典 给随机字符串添加忽略注释 导出/导入配置导出配置以备份、与团队成员共享]]></content>
      <categories>
        <category>新手村</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel/Lumen 扩展DB Builder语法]]></title>
    <url>%2Fp%2F1734.html</url>
    <content type="text"><![CDATA[截至5.6版本，Laravel的DB Builder都没有方法实现忽略插入与插入或更新（5.7版本新增updateOrInsert()）。除了自己封装多一层之外，还有一个更优雅的解决方案是对Builder语法进行扩展。 扩展支持的语法这里要扩展的是三个常用的语法: INSERT IGNORE INTO REPLACE INTO INSERT INTO ... ON DUPLICATE KEY UPDATE 扩展Builder类Laravel官方已经在Illuminate\Database包中提供了扩展实例，需要创建自定义的Grammar、Builder、Connection类，然后由服务提供者注册。 自定义Grammar123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;?phpnamespace App\Library\Database\Query\Grammars;use Illuminate\Database\Query\Grammars\MySqlGrammar as Grammar;use App\Library\Database\Query\MySqlBuilder as Builder;class MySqlGrammar extends Grammar&#123; /** * Compile a replace into statement into SQL. * * @link https://dev.mysql.com/doc/refman/5.5/en/replace.html * * @param \App\Library\Database\Query\MySqlBuilder $query * @param array $values * @return string */ public function compileReplace(Builder $query, array $values) &#123; // Essentially we will force every insert to be treated as a batch insert which // simply makes creating the SQL easier for us since we can utilize the same // basic routine regardless of an amount of records given to us to insert. $table = $this-&gt;wrapTable($query-&gt;from); if (!is_array(reset($values))) &#123; $values = [$values]; &#125; $columns = $this-&gt;columnize(array_keys(reset($values))); // We need to build a list of parameter place-holders of values that are bound // to the query. Each insert should have the exact same amount of parameter // bindings so we will loop through the record and parameterize them all. $parameters = []; foreach ($values as $record) &#123; $parameters[] = '(' . $this-&gt;parameterize($record) . ')'; &#125; $parameters = implode(', ', $parameters); return "REPLACE INTO $table ($columns) VALUES $parameters"; &#125; /** * Compile an insert ignore statement into SQL. * * @link https://dev.mysql.com/doc/refman/5.5/en/insert.html * * @param \App\Library\Database\Query\MySqlBuilder $query * @param array $values * @return string */ public function compileInsertIgnore(Builder $query, array $values) &#123; // Essentially we will force every insert to be treated as a batch insert which // simply makes creating the SQL easier for us since we can utilize the same // basic routine regardless of an amount of records given to us to insert. $table = $this-&gt;wrapTable($query-&gt;from); if (!is_array(reset($values))) &#123; $values = [$values]; &#125; $columns = $this-&gt;columnize(array_keys(reset($values))); // We need to build a list of parameter place-holders of values that are bound // to the query. Each insert should have the exact same amount of parameter // bindings so we will loop through the record and parameterize them all. $parameters = []; foreach ($values as $record) &#123; $parameters[] = '(' . $this-&gt;parameterize($record) . ')'; &#125; $parameters = implode(', ', $parameters); return "INSERT IGNORE INTO $table ($columns) VALUES $parameters"; &#125; /** * Compile an insert update statement into SQL. * * @link https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html * @link https://gist.github.com/RuGa/5354e44883c7651fd15c * * @param \App\Library\Database\Query\MySqlBuilder $query * @param array $values * @return string */ public function compileInsertUpdate(Builder $query, array $values) &#123; // Essentially we will force every insert to be treated as a batch insert which // simply makes creating the SQL easier for us since we can utilize the same // basic routine regardless of an amount of records given to us to insert. $table = $this-&gt;wrapTable($query-&gt;from); $columnNames = array_keys(reset($values)); $columns = $this-&gt;columnize($columnNames); $parameters = implode(',', array_map(function ($row) &#123; return '(' . $this-&gt;parameterize($row) . ')'; &#125;, $values)); $updates = implode(',', array_map(function ($columnName) &#123; return $this-&gt;wrap($columnName) . ' = VALUES(' . $this-&gt;wrap($columnName) . ')'; &#125;, $columnNames)); return "INSERT INTO $table ($columns) VALUES $parameters ON DUPLICATE KEY UPDATE $updates"; &#125;&#125; 自定义Builder123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;?phpnamespace App\Library\Database\Query;use Illuminate\Database\Query\Builder as QueryBuilder;class MySqlBuilder extends QueryBuilder&#123; /** * The database query grammar instance. * * @var Grammars\MySqlGrammar */ public $grammar; /** * Insert a new record into the database, replace on primary key conflict. * * @param array $values * @return bool */ public function replace(array $values) &#123; if (empty($values)) &#123; return true; &#125; // Since every insert gets treated like a batch insert, we will make sure the // bindings are structured in a way that is convenient for building these // inserts statements by verifying the elements are actually an array. if (!is_array(reset($values))) &#123; $values = [$values]; &#125; // Since every insert gets treated like a batch insert, we will make sure the // bindings are structured in a way that is convenient for building these // inserts statements by verifying the elements are actually an array. else &#123; foreach ($values as $key =&gt; $value) &#123; ksort($value); $values[$key] = $value; &#125; &#125; // We'll treat every insert like a batch insert so we can easily insert each // of the records into the database consistently. This will make it much // easier on the grammars to just handle one type of record insertion. $bindings = []; foreach ($values as $record) &#123; foreach ($record as $value) &#123; $bindings[] = $value; &#125; &#125; $sql = $this-&gt;grammar-&gt;compileReplace($this, $values); // Once we have compiled the insert statement's SQL we can execute it on the // connection and return a result as a boolean success indicator as that // is the same type of result returned by the raw connection instance. $bindings = $this-&gt;cleanBindings($bindings); return $this-&gt;connection-&gt;insert($sql, $bindings); &#125; /** * Insert a new record into the database, update on primary key conflict. * * @param array $values * @return bool */ public function insertUpdate(array $values) &#123; if (empty($values)) &#123; return true; &#125; // Since every insert gets treated like a batch insert, we will make sure the // bindings are structured in a way that is convenient for building these // inserts statements by verifying the elements are actually an array. if (!is_array(reset($values))) &#123; $values = [$values]; &#125; // Sort the keys in each row alphabetically for consistency else &#123; foreach ($values as $key =&gt; $value) &#123; ksort($value); $values[$key] = $value; &#125; &#125; // We'll treat every insert like a batch insert so we can easily insert each // of the records into the database consistently. This will make it much // easier on the grammars to just handle one type of record insertion. $bindings = []; foreach ($values as $record) &#123; foreach ($record as $value) &#123; $bindings[] = $value; &#125; &#125; $sql = $this-&gt;grammar-&gt;compileInsertUpdate($this, $values); // Once we have compiled the insert statement's SQL we can execute it on the // connection and return a result as a boolean success indicator as that // is the same type of result returned by the raw connection instance. $bindings = $this-&gt;cleanBindings($bindings); return $this-&gt;connection-&gt;insert($sql, $bindings); &#125; /** * Insert a new record into the database, discard on primary key conflict. * * @param array $values * @return bool */ public function insertIgnore(array $values) &#123; if (empty($values)) &#123; return true; &#125; // Since every insert gets treated like a batch insert, we will make sure the // bindings are structured in a way that is convenient for building these // inserts statements by verifying the elements are actually an array. if (!is_array(reset($values))) &#123; $values = [$values]; &#125; // Since every insert gets treated like a batch insert, we will make sure the // bindings are structured in a way that is convenient for building these // inserts statements by verifying the elements are actually an array. else &#123; foreach ($values as $key =&gt; $value) &#123; ksort($value); $values[$key] = $value; &#125; &#125; // We'll treat every insert like a batch insert so we can easily insert each // of the records into the database consistently. This will make it much // easier on the grammars to just handle one type of record insertion. $bindings = []; foreach ($values as $record) &#123; foreach ($record as $value) &#123; $bindings[] = $value; &#125; &#125; $sql = $this-&gt;grammar-&gt;compileInsertIgnore($this, $values); // Once we have compiled the insert statement's SQL we can execute it on the // connection and return a result as a boolean success indicator as that // is the same type of result returned by the raw connection instance. $bindings = $this-&gt;cleanBindings($bindings); return $this-&gt;connection-&gt;insert($sql, $bindings); &#125;&#125; 自定义Connection123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\Library\Database;use App\Library\Database\Query\MySqlBuilder as Builder;use App\Library\Database\Query\Grammars\MySqlGrammar as QueryGrammar;use Illuminate\Database\MySqlConnection as Connection;class MySqlConnection extends Connection&#123; /** * Get the default query grammar instance. * * @return \Illuminate\Database\Grammar|\Illuminate\Database\Query\Grammars\MySqlGrammar */ protected function getDefaultQueryGrammar() &#123; return $this-&gt;withTablePrefix(new QueryGrammar); &#125; /** * Get a new query builder instance. * * @return \App\Library\Database\Query\MySqlBuilder */ public function query() &#123; return new Builder( $this, $this-&gt;getQueryGrammar(), $this-&gt;getPostProcessor() ); &#125;&#125; 自定义Provider12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App\Providers;use App\Library\Database\MySqlConnection;use Illuminate\Support\ServiceProvider;class DatabaseServiceProvider extends ServiceProvider&#123; /** * Override the default connection for MySQL. This allows us to use `replace` etc. * * @link https://stidges.com/extending-the-connection-class-in-laravel * @link https://gist.github.com/VinceG/0fb570925748ab35bc53f2a798cb517c * * @return void */ public function boot() &#123; Connection::resolverFor('mysql', function ($connection, $database, $prefix, $config) &#123; return new MySqlConnection($connection, $database, $prefix, $config); &#125;); // 5.4及以上版本使用此方式绑定 &#125; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;bind('db.connection.mysql', MySqlConnection::class); // 5.4版本以下使用此方式绑定 &#125;&#125; 注册ProviderLaravel在config/app.php里的providers中添加新的Provider类:12345'providers' =&gt; [ // 其他的服务提供者 App\Providers\AppServiceProvider::class,], Lumen在bootstrap/app.php中手动绑定:1234// 扩展的查询语法：Replace、InsertIgnore、InsertUpdate$app-&gt;register(App\Providers\DatabaseServiceProvider::class);return $app; 使用Demo12345$data = [ 'name' =&gt; 'soap', 'status' =&gt; 'kia'];\DB::connection('cod8')-&gt;table('141_members')-&gt;insertUpdate($data); 注意这里输入\DB::connection()-&gt;table()-&gt;之后IDE不会提示扩展的方法，只能在封装类中声明是自定义的Builder以获得提示。 封装成组件参照使用satis搭建私有Composer库 Refrenceshttps://stidges.com/extending-the-connection-class-in-laravelhttps://gist.github.com/VinceG/0fb570925748ab35bc53f2a798cb517chttps://github.com/art-institute-of-chicago/data-service-images]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 接收PUT/PATCH/DELETE请求的值]]></title>
    <url>%2Fp%2F613f.html</url>
    <content type="text"><![CDATA[最近在调试PUT接口时，控制器中Request对象无法正常获取表单内容，发现这是Symfony组件的经典问题。 What当时的场景是前端ajax使用PUT方式提交了一个multipart/form-data的请求，但是Request对象无法使用get()获取到数据。 WhyLaravel的Illuminate\Http\Request对象继承是Symfony\Component\HttpFoundation\Request，在获取请求表单内容的代码如下[1]： 1234567891011public static function createFromGlobals() &#123; $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $_SERVER); if (0 === strpos($request-&gt;headers-&gt;get('CONTENT_TYPE'), 'application/x-www-form-urlencoded') &amp;&amp; \in_array(strtoupper($request-&gt;server-&gt;get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH']) ) &#123; parse_str($request-&gt;getContent(), $data); $request-&gt;request = new ParameterBag($data); &#125; return $request; &#125; 由于PHP原生只支持$_GET、$_POST，所以PUT、PATCH、DELETE的表单内容要从$request-&gt;getContent()中解析，但这里进行解析有一个条件是请求头Content-Type为application/x-www-form-urlencoded，所以当我使用multipart/form-data的Content-Type进行PUT请求时，Request对象就无法正常解析。 How解决方案有以下三个： 请求前 将Content-Type设置为application/x-www-form-urlencoded 覆盖请求头method: 将请求头method设为POST，同时将请求头X-HTTP-METHOD-OVERRIDE 或 _method（url参数或请求体皆可）设为PUT/PATCH/DELETE。 Laravel官方给出的建议方案[2]也是方案二中的后者。 123456789101112if (! function_exists('method_field')) &#123; /** * Generate a form field to spoof the HTTP verb used by forms. * * @param string $method * @return \Illuminate\Support\HtmlString */ function method_field($method) &#123; return new HtmlString('&lt;input type="hidden" name="_method" value="'.$method.'"&gt;'); &#125;&#125; Symfony包中默认是禁用$httpMethodParameterOverride，而Laravel中默认开启。禁用时，只能通过请求头X-HTTP-METHOD-OVERRIDE覆盖。开启时，覆盖的优先级为：请求头X-HTTP-METHOD-OVERRIDE &gt; 请求体_method &gt; url参数_method &gt; 请求头method [3]12345678910111213141516public function getMethod() &#123; if (null === $this-&gt;method) &#123; $this-&gt;method = strtoupper($this-&gt;server-&gt;get('REQUEST_METHOD', 'GET')); if ('POST' === $this-&gt;method) &#123; if ($method = $this-&gt;headers-&gt;get('X-HTTP-METHOD-OVERRIDE')) &#123; $this-&gt;method = strtoupper($method); &#125; elseif (self::$httpMethodParameterOverride) &#123; $this-&gt;method = strtoupper($this-&gt;request-&gt;get('_method', $this-&gt;query-&gt;get('_method', 'POST'))); &#125; &#125; &#125; return $this-&gt;method; &#125; 请求后 继承Request对象补充对multipart/form-data类型的内容解析 Reference https://learnku.com/laravel/t/14028/how-does-laravel-put-receive-values#reply56870]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel5.2 使用队列记录接口日志]]></title>
    <url>%2Fp%2F618f.html</url>
    <content type="text"><![CDATA[最近在开发一个新接口时，需要记录请求与响应的日志。为了提高接口响应速度，记录日志这个环节就由异步队列来完成。项目采用Laravel5.2，队列驱动使用Redis。 配置Laravel 5.2自带的redis队列驱动中会用到watch命令，所以没办法直接使用集群。要么自己写驱动，要么队列单独使用另外的主备redis。我这边是采用后者。 增加redis连接配置.env123456789101112// 队列驱动QUEUE_DRIVER=redis// 集群REDIS_HOST=xxx.xxx.xxx.xxxREDIS_PASSWORD=xxxREDIS_PORT=xxxx// 主备QUEUE_REDIS_HOST=xxx.xxx.xxx.xxxQUEUE_REDIS_PASSWORD=xxxQUEUE_REDIS_PORT=xxxx config/database.php123456789101112131415161718'redis' =&gt; [ 'cluster' =&gt; false, 'default' =&gt; [ 'host' =&gt; env('REDIS_HOST', 'localhost'), 'password' =&gt; env('REDIS_PASSWORD', null), 'port' =&gt; env('REDIS_PORT', 6379), 'database' =&gt; 0, ], 'queue' =&gt; [ 'host' =&gt; env('QUEUE_REDIS_HOST', 'localhost'), 'password' =&gt; env('QUEUE_REDIS_PASSWORD', null), 'port' =&gt; env('QUEUE_REDIS_PORT', 6379), 'database' =&gt; 0, ],], 指定队列使用的redis连接config/queue.php1234567891011'default' =&gt; env('QUEUE_DRIVER', 'sync'),...'connections' =&gt; [ 'redis' =&gt; [ 'driver' =&gt; 'redis', 'connection' =&gt; 'queue', 'queue' =&gt; 'default', 'expire' =&gt; 60, ],],... 创建Worker1php artisan make:job SaveMatchLog 与自动计划的Command类一样，在handle()中编写具体业务代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class SaveMatchLog extends Job implements ShouldQueue&#123; use InteractsWithQueue, SerializesModels; /** * 请求的订单号 * @var string */ private $orderNo; /** * 请求时间 * @var array */ private $time; /** * 请求IP * @var array */ private $ip; /** * 客户端系统信息 * @var array */ private $userAgent; /** * 响应信息 * @var array */ private $msg; /** * saveMatchLog constructor. * @param Request $req * @param \Illuminate\Http\JsonResponse $res */ public function __construct($req, $res) &#123; $this-&gt;orderNo = $req-&gt;get('order_no'); $this-&gt;time = date('Y-m-d H:i:s', $req-&gt;server-&gt;get('REQUEST_TIME')); $this-&gt;ip = $req-&gt;getClientIp(); $this-&gt;userAgent = $req-&gt;header('user-agent'); $this-&gt;msg = $res-&gt;getData(); &#125; /** * Execute the job. * * @return void */ public function handle() &#123; // 日志内容 $content = $this-&gt;getLogContent(); // 输出日志 $logWriter = new Writer(new Logger('match')); $logWriter-&gt;useDailyFiles(storage_path('logs/match/match.log')); $logWriter-&gt;info($content); &#125; public function failed() &#123; $content = $this-&gt;getLogContent(); \Log::error('记录请求响应日志到logs/match.log失败，日志将记录在系统日志logs/laravel.log中'); \Log::info($content); &#125; /** * @return string */ private function getLogContent() &#123; return json_encode([ 'orderNo' =&gt; $this-&gt;orderNo, 'time' =&gt; $this-&gt;time, 'ip' =&gt; $this-&gt;ip, 'userAgent' =&gt; $this-&gt;userAgent, 'msg' =&gt; $this-&gt;msg, ], JSON_UNESCAPED_UNICODE); &#125;&#125; 添加到队列接口的Controller如下123456789101112131415161718192021/** * 接口入口 * @param Request $request * @return \Illuminate\Http\JsonResponse */public function match(Request $request)&#123; $response = $this-&gt;_match($request); $job = (new SaveMatchLog($request, $response)); $this-&gt;dispatch($job); // 使用队列存储日志，提高接口响应速度 return $response;&#125;/** * @param Request $request * @return \Illuminate\Http\JsonResponse */public function _match(Request $request)&#123; // do sth&#125; 监听队列采用supervisor来管理监听进程 进程配置1234567891011$ cat /etc/supervisor/conf.d/laravel-worker.conf[program:laravel-worker]process_name=%(program_name)s_%(process_num)02dcommand=php /data/www/newadminpk/artisan queue:work redis --sleep=3 --tries=3 --daemonautostart=trueautorestart=trueuser=wwwnumprocs=1redirect_stderr=truestdout_logfile=/data/www/newadminpk/storage/logs/worker.out.logstderr_logfile=/data/www/newadminpk/storage/logs/worker.err.log 引入配置123$ tail /etc/supervisord/supervisord.conf[include]files = ./conf.d/*.conf 启动supervisor1sudo supervisord -c supervisor.conf 启动队列监听器123sudo supervisorctl rereadsudo supervisorctl updatesudo supervisorctl start laravel-worker:* 12$ ps -ef | grep artisan | grep -v grepwww 21064 3186 0 14:49 ? 00:00:01 php /data/www/newadminpk/artisan queue:work redis --sleep=3 --tries=3 --daemon 其他Walle配置这个项目通过Walle部署，需要在项目配置的post-release中配置以下1sudo supervisorctl restart laravel-worker:* 否则每次发布新版本后，Worker还是会将日志保存到上一个版本的路径下，导致日志丢失（这一点只要熟悉Walle的原理就知道原因了）。 ELK优化目前日志处理与检索还属于低频需求，后期可以考虑采用ELK改进写入日志之后的流程。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode FTP与SSH插件推荐]]></title>
    <url>%2Fp%2F1cfa.html</url>
    <content type="text"><![CDATA[因为一些不可抗力因素，我偶尔要直接在线上改文件，这时就要在几个工具间反复切换（xftp下载，sublime编辑，xftp上传，xshell执行），比较繁琐。最近刚好改用VSCode，在市场找到两个比较合适的插件，在一个编辑器内即可完成上述流程，非常顺滑。 SSH FS如果你直接在市场搜FTP的话，那些插件都是和xftp一样，每次修改文件都需要先下载。万一忘了，就可能丢失部分代码。而这款SSH FS是利用ssh模拟文件系统，所以你每次打开时，文件内容与目录机构都是最新的。 SSHExtension这个插件也比较简单，就是直接使用VSCode的终端执行ssh命令。不过ssh配置是共用了另一款ftp插件ftp-simple的配置文件，所以也需要一起安装。 最后VSCode真香，不像Sublime那么折腾。]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel5.2 DB Builder 子查询的优雅写法]]></title>
    <url>%2Fp%2Fba95.html</url>
    <content type="text"><![CDATA[Laravel5.2的DB Builder还没有fromSub()与joinSub()，Sql涉及子查询时，比较优雅的写法是利用toSql()与mergeBindings()。 From1234567SELECT *FROM ( SELECT * FROM t1 WHERE c1 = xxx AND c2 = xxx GROUP BY c1 ) AS sub WHERE c1 = xxx AND c2 = xxx; 1234567$subQuery = DB::table('t1')-&gt;where('c1', 'xxx')-&gt;where('c2', xxx)-&gt;groupBy('c1');$query = DB::table(DB::raw("(&#123;$subQuery-&gt;toSql()&#125;) as sub")) -&gt;select(['*']) -&gt;where('c1', 'xxx') -&gt;where('c2', 'xxx'); -&gt;mergeBindings($subQuery) -&gt;get(); Join1234567SELECT t1.*, sub.c4 FROM t1 LEFT JOIN ( SELECT * FROM t2 GROUP BY c1, c2 ) AS sub ON t1.c1 = t2.c1 AND t1.c2 = t2.c2 12345678910$subQuery = DB::table('t2')-&gt;groupBy('c1', 'c2');$query = DB::table('t1') -&gt;select(['t1.*', 'sub.c4']) -&gt;leftJoin(DB::raw("(&#123;subQuery-&gt;toSql()&#125;) as sub"), function ($join) &#123; /** @var JoinClause $join */ $join-&gt;on('t1.c1', '=', 't2.c1') -&gt;on('t1.c2', '=', 't2.c2'); &#125;) -&gt;mergeBindings($subQuery) -&gt;get();]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用github issue存放文章与评论]]></title>
    <url>%2Fp%2F9414.html</url>
    <content type="text"><![CDATA[Hexo默认文章存放于source分支，没有评论系统，不过都可以通过插件进行扩展。本文介绍如何将hexo的文章与评论存放于Github Issue中（issue内容为博客内容，issue评论为博客评论）。 使用github issue存放文章这种方案主要优点是可以直接使用GitHub的图床。注意: 19年10月开始githubusercontent.com域名被墙，需要科学才能看到图片 安装插件1$ npm install hexo-migrator-github-issue --save 新建issue文章 使用GitHub图床非常简单，把图片文件拖到编辑框就行了~ 导入文章1$ hexo migrate github-issue 你的Github用户名/你存放hexo的仓库名 例如然后生成部署即可。 插件扩展该插件会根据issue的label为文章生成标签，如果要想生成分类和置顶参数，需要做一些修改。 我提了一个PR还没通过，这里直接使用我fork的分支替换。 1curl -fsSL https://raw.githubusercontent.com/CloudyCity/hexo-migrator-github-issue/master/index.js &gt; node_modules/hexo-migrator-github-issue/index.js 使用github issue存放评论安装插件Next主题自带gitment，主文件是/themes/next/source/js/src/gitment.browser.js。 如果是其他主题，需要安装gitment，主文件是/node_modules/gitment/dist/gitment.browser.js。 1$ npm install gitment --save 创建授权应用点击这里创建，名称随意，两个url都填hexo博客的url，创建完成就得到应用ID和密钥。 创建新仓库在GitHub中创建一个新仓库，其issue将用于存放评论。 配置在Next主题的配置文件_config.yaml中更改以下配置 1234567gitment: enable: true githubID: 你的github用户名 repo: 博客所在仓库 ClientID: 应用ID ClientSecret: 密钥 lazy: false 修改授权时的跨域转发更改gitment主文件，将中以下内容 1_utils.http.post('https://gh-oauth.imsun.net', &#123; 修改为 1_utils.http.post('https://cors.wenjunjiang.win/?remoteUrl=https://github.com/login/oauth/access_token', &#123; 目前原作者提供的服务正常，无需修改。 插件修改此插件原本是使用另一个仓库存放评论，现在的需求是用博客所在仓库的对应文章issue中存放评论，需要修改loadMeta()，让插件使用id获取issue。 这里使用hexo-migrator-github-issue作者Yikunfork的分支，用webpack打包，覆盖gitment主文件。 Next主题可参考本博客的gitment.browser.js 非Next主题可参考我写的替换脚本gitment.sh 主题修改这里使用的是Next主题，需要修改三个模板文件，将hexo-migrator-github-issue插件获取到的issue-number作为id，供gitment插件中的loadMeta()使用。 \themes\next\layout\_partials\comments\gitment.swig \themes\next\layout\_script\comments\gitment.swig \themes\next\layout\_third-party\comments\gitment.swig 123&#123;% if theme.gitment.enable %&#125; &#123;% set id = page.number %&#125; &#123;% set owner = theme.gitment.githubID %&#125; 可以将主题加入版本控制，更换机器后就不需要再操作一遍，不过也会导致gitment的密钥泄漏:( 最后最终效果参照本文章对应issue 如果大家觉得上面两个插件好用的话可以去给插件的项目点个星支持开发者哦~hexo-migrator-github-issuegitment]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo博客]]></title>
    <url>%2Fp%2Fee20.html</url>
    <content type="text"><![CDATA[Hexo是一种使用Node.js编写的静态博客框架，快速、简洁、扩展丰富。本文介绍如何搭建Hexo博客，并部署到GitHub Page。 前言个人认为，写博客是一个程序猿记录和总结的最好方式，虽然写博文没有使用笔记软件记录那么方便，需要更加严谨，但我觉得这其实是好事，可以迫使你更加认真的去钻研，而不只是浅尝辄止。长期坚持下来，可以改变你的学习态度，受益匪浅。 不过我本来并不打算写这篇博文，因为网上已经有太多的教程，没有必要重复造轮子。但是我在搭建过程遇到很多问题，花了不少时间，所以还是决定记录下来。 简介Hexo是一种使用Node.js编写的静态博客框架，快速、简洁、扩展丰富。 搭建完成后使用非常简单： 在hexo项目目录下的\source\_posts\中用Markdown语法写博文； 生成静态文件（Hexo将MD文件其解析成HTML文件）并部署。 搭建本教程将Hexo部署到GitHub Page ，可以节省域名和空间的费用。 安装与配置Git如果你是初次使用，安装时一路Next即可，然后打开Git Bash进行用户配置。12$ git config --global user.name 你的用户名$ git config --global user.email 你的邮箱 生成SSH公钥。1$ ssh-keygen 首先 ssh-keygen 会确认密钥的存储位置（默认是 .ssh/id_rsa），然后它会要求你输入两次密钥口令。如果你不想在使用密钥，直接回车即可。接下来使用cat命令查看公钥，下一步会用到。 1$ cat ~/.ssh/id_rsa.pub 创建GitHub仓库创建一个仓库，名称必须是你的GitHub用户名.github.io，例如我的是仓库名为CloudyCity.github.io。然后进入Setting页面将上一步生成的公钥添加进去，以获得让你的电脑获得访问仓库的权限。 安装与配置Hexo接下来就可以开始正题了，安装后使用管理员身份打开Git Bash。1$ npm install hexo-cli -g 进入你打算存放本地仓库的文件夹，初始化Hexo，并安装依赖。1$ hexo init 之后可以查看Hexo版本。1$ hexo -v Hexo 3.0 之后需要另外安装deployer才能部署。1$ npm install hexo-deployer-git --save 现在可以先进行本地测试，首先生成静态页面。1$ hexo g 然后启用本地服务，用浏览器打开 localhost:4000，如果没问题继续往下。1$ hexo s 打开Hexo文件夹下的_config.yml，这里只说明关于部署的配置项，其他配置项请移步至Hexo文档 。1234deploy: type: git repository: git@github.com:CloudyCity/CloudyCity.github.io.git branch: master 将这里的repository的值改为你的GitHub仓库的SSH地址即可。激动人心的时刻来了，执行部署。1$ hexo d 如果你上面的步骤的都没问题的话，这时候在浏览器直接访问你的仓库名 (例:https://cloudycity.github.io) 就可以看到你的博客了。 上传Hexo的源码打开Hexo文件夹，创建Git本地仓库1$ git init 创建新分支1$ git branch source 切换成source分支1$ git checkout source 追踪所有文件1$ git add . 提交更改（到本地仓库）1$ git commit -m 'first time upload source' 添加远程仓库，这里也是键入你的GitHub仓库的SSH地址1$ git remote add origin git@github.com:CloudyCity/CloudyCity.github.io.git 推送到远程仓库1$ git push origin source 如果没遇到问题，那恭喜你成功将Hexo源码推送到你在GitHub的名称为你的GitHub用户名.github.io的仓库的source分支中！这样以后你换一台设备亦可以继续写博文啦~（当然你还是需要添加新设备的公钥到GitHub中） 需要注意的是，因为文章存放在source分支中，所以每次写好一篇新文章，应该提交并推送到远程分支中。 下载Hexo的源码这里假如你换了一台设备，打开你打算作为本地仓库的文件夹，创建本地仓库，生成与添加公钥的步骤不再赘述。 克隆远程仓库1$ git clone git@github.com:CloudyCity/CloudyCity.github.io.git 切换source分支1$ git checkout source 源码中的package.json已保存依赖信息，这里只需要自动安装即可。1$ npm install 这样子就再次搭建好Hexo环境啦~ 最后搭建完成只是开始，坚持用心写文章才是最难的，大家一起加油。另外，hexo还有非常多好看的主题和有用的插件哦~]]></content>
      <categories>
        <category>新手村</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
